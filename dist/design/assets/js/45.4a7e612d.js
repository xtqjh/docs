(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{392:function(e,a,n){"use strict";n.r(a);var t=n(42),r=Object(t.a)({},(function(){var e=this,a=e.$createElement,n=e._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"多人联机射击游戏中的设计模式应用-二"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#多人联机射击游戏中的设计模式应用-二"}},[e._v("#")]),e._v(" 多人联机射击游戏中的设计模式应用（二）")]),e._v(" "),n("p",[e._v("(6) 观察者模式")]),e._v(" "),n("p",[e._v("联机射击游戏可以实时显示队友和敌人的存活信息，如果有队友或敌人阵亡，所有在线游戏玩家将收到相应的消息，可以提供一个统一的中央角色控制类(CenterController)来实现消息传递机制，在中央角色控制器中定义一个集合用于存储所有的玩家信息，如果某玩家角色(Player)阵亡，则调用CenterController的通知方法notifyPlayers()，该方法将遍历用户信息集合，调用每一个Player的display()方法显示阵亡信息，队友阵亡和敌人阵亡的提示信息有所不同，在使用notifyPlayers()方法通知其他用户的同时，阵亡的角色对象将从用户信息集合中被删除。可使用观察者模式来实现信息的一对多发送，类图如图6所示：")]),e._v(" "),n("p",[n("img",{attrs:{src:"http://img.my.csdn.net/uploads/201212/06/1354723472_2717.jpg",alt:""}})]),e._v(" "),n("p",[e._v("图6 观察者模式实例类图")]),e._v(" "),n("p",[e._v("在图6中，CenterController充当观察目标，Observer充当抽象观察者，Player充当具体观察者。在Player类中，name属性表示角色名，type属性表示角色类型，如“战队A”或“战队B”等。Player的die()方法执行时将调用CenterController的notifyPlayers()方法，在notifyPlayers()方法中调用其他Player对象的提示方法，如果是队友阵亡则调用displayTeam()，如果是敌人阵亡则调用displayEnemy()；还将调用detach()方法删除阵亡的Player对象，其中CenterController类的notifyPlayers()方法代码片段如下所示：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("for(Object player : players) {  \n    if(player.getName().equals(name)) {  \n      this.detach(player);  //删除阵亡的角色  \n     }  \n    else {  \n        if(player.getType().equals(type)) {  \n            player.displayTeam(name);  //队友显示提示信息  \n         }  \n        else {  \n            player.displayEnemy(name);  //敌人显示提示信息  \n          }  \n    }  \n}  \n")])])]),n("p",[e._v("(7) 单例模式")]),e._v(" "),n("p",[e._v("为了节约系统资源，在联机射击游戏中可以使用单例模式来实现一些管理器(Manager)，如场景管理器(SceneManager)、声音管理器(SoundManager)等，如图7所示的场景管理器SceneManager类：")]),e._v(" "),n("p",[n("img",{attrs:{src:"http://img.my.csdn.net/uploads/201212/06/1354723530_2433.jpg",alt:""}})]),e._v(" "),n("p",[e._v("图7 单例模式实例类图")]),e._v(" "),n("p",[e._v("SceneManager类的实现代码片段如下所示【注：以下代码未考虑多线程访问的问题】：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class SceneManager {  \n    private static SceneManager sManager = null;  \n  \n    private SceneManager() {  \n        //初始化代码  \n    }  \n  \n    public synchronized static SceneManager getInstance() {  \n        if(sManager==null) {  \n            sManager = new SceneManager();  \n        }  \n        return sManager;  \n    }  \n  \n    public void manage() {  \n        //业务方法  \n    }  \n}  \n")])])]),n("p",[e._v("(8) 状态模式")]),e._v(" "),n("p",[e._v("在射击游戏中，游戏角色存在几种不同的状态，如正常状态、暂停状态、阵亡状态等，在不同状态下角色对象的行为不同，可使用状态模式来设计和实现角色状态的转换，类图如图8所示：")]),e._v(" "),n("p",[n("img",{attrs:{src:"http://img.my.csdn.net/uploads/201212/06/1354723562_1798.jpg",alt:""}})]),e._v(" "),n("p",[e._v("图8 状态模式实例类图")]),e._v(" "),n("p",[e._v("在图8中，游戏角色类Player充当环境类，State充当抽象状态类，其子类NormalState、PauseState和DeathState充当具体状态类，在具体状态类的pause()、start()、beAttacked()等方法中可实现状态转换，其中NormalState类的代码片段如下所示：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class NormalState extends State  \n{  \n    public void pause()  //游戏暂停  \n    {  \n        //暂停代码省略  \n        player.setState(new PauseState(this));  //转为暂停状态  \n    }  \n    public void start()  //游戏启动  \n    {  \n        //游戏程序正在运行中，该方法不可用  \n    }  \n    public void beAttacked()  //被攻击  \n    {  \n        //其他代码省略  \n        if(lifeValue<=0)  \n        {  \n            player.setState(new DeathState(this));  //转为阵亡状态  \n        }  \n    }  \n    public void shot()  //射击  \n    {  \n        //代码省略  \n    }  \n    public void move()  //移动  \n    {  \n        //代码省略  \n    }  \n}  \n")])])]),n("p",[e._v("(9) 适配器模式")]),e._v(" "),n("p",[e._v("为了增加游戏的灵活性，某些射击游戏还可以通过游戏手柄来进行操作，游戏手柄的操作程序和驱动程序由游戏手柄制造商提供，为了让当前的射击游戏可以与游戏手柄兼容，可使用适配器模式来进行设计，类图如图9所示：")]),e._v(" "),n("p",[n("img",{attrs:{src:"http://img.my.csdn.net/uploads/201212/06/1354723596_1612.jpg",alt:""}})]),e._v(" "),n("p",[e._v("图9 适配器模式实例类图")]),e._v(" "),n("p",[e._v("在图9中，GamepadsAdapter充当适配器，它将游戏手柄中按键(GamepadsKey)的方法适配到现有系统中，在其move()方法中可以调用MoveKey类的handle()方法，在其shot()方法中可以调用ShotKey的handle()方法，从而实现通过手柄来控制游戏运行。")])])}),[],!1,null,null,null);a.default=r.exports}}]);