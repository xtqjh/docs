(window.webpackJsonp=window.webpackJsonp||[]).push([[150],{496:function(e,s,t){"use strict";t.r(s);var n=t(42),a=Object(n.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"请求的链式处理-职责链模式-二"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#请求的链式处理-职责链模式-二"}},[e._v("#")]),e._v(" 请求的链式处理——职责链模式（二）")]),e._v(" "),t("p",[e._v("16.2 职责链模式概述")]),e._v(" "),t("p",[e._v("很多情况下，在一个软件系统中可以处理某个请求的对象不止一个，例如SCM系统中的采购单审批，主任、副董事长、董事长和董事会都可以处理采购单，他们可以构成一条处理采购单的链式结构，采购单沿着这条链进行传递，这条链就称为职责链。职责链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。链上的每一个对象都是请求处理者，职责链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理，客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，实现请求发送者和请求处理者解耦。")]),e._v(" "),t("p",[e._v("职责链模式定义如下：\n职责链模式(Chain of Responsibility  Pattern)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。")]),e._v(" "),t("p",[e._v("职责链模式结构的核心在于引入了一个抽象处理者。职责链模式结构如图16-2所示：")]),e._v(" "),t("p",[t("img",{attrs:{src:"http://my.csdn.net/uploads/201204/02/1333307613_2407.gif",alt:""}})]),e._v(" "),t("p",[e._v("在职责链模式结构图中包含如下几个角色：")]),e._v(" "),t("p",[e._v("● Handler（抽象处理者）：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象（如结构图中的successor），作为其对下家的引用。通过该引用，处理者可以连成一条链。")]),e._v(" "),t("p",[e._v("● ConcreteHandler（具体处理者）：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。")]),e._v(" "),t("p",[e._v("在职责链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。")]),e._v(" "),t("p",[e._v("职责链模式的核心在于抽象处理者类的设计，抽象处理者的典型代码如下所示：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("abstract class Handler {  \n    //维持对下家的引用  \nprotected Handler successor;  \n      \n    public void setSuccessor(Handler successor) {  \n        this.successor=successor;  \n    }  \n      \n    public abstract void handleRequest(String request);  \n}  \n")])])]),t("p",[e._v("上述代码中，抽象处理者类定义了对下家的引用对象，以便将请求转发给下家，该对象的访问符可设为protected，在其子类中可以使用。在抽象处理者类中声明了抽象的请求处理方法，具体实现交由子类完成。")]),e._v(" "),t("p",[e._v("具体处理者是抽象处理者的子类，它具有两大作用：第一是处理请求，不同的具体处理者以不同的形式实现抽象请求处理方法handleRequest()；第二是转发请求，如果该请求超出了当前处理者类的权限，可以将该请求转发给下家。具体处理者类的典型代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class ConcreteHandler extends Handler {  \n    public void handleRequest(String request) {  \n        if (请求满足条件) {  \n            //处理请求  \n        }  \n        else {  \n            this.successor.handleRequest(request);  //转发请求  \n        }  \n    }  \n}  \n")])])]),t("p",[e._v("在具体处理类中通过对请求进行判断可以做出相应的处理。")]),e._v(" "),t("p",[e._v("需要注意的是，职责链模式并不创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般是在使用该职责链的客户端中创建职责链。职责链模式降低了请求的发送端和接收端之间的耦合，使多个对象都有机会处理这个请求。")]),e._v(" "),t("p",[e._v("思考")]),e._v(" "),t("p",[e._v("如何在客户端创建一条职责链？")])])}),[],!1,null,null,null);s.default=a.exports}}]);