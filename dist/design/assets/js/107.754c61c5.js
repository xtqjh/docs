(window.webpackJsonp=window.webpackJsonp||[]).push([[107],{453:function(n,e,a){"use strict";a.r(e);var r=a(42),t=Object(r.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"确保对象的唯一性-单例模式-二"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#确保对象的唯一性-单例模式-二"}},[n._v("#")]),n._v(" 确保对象的唯一性——单例模式 （二）")]),n._v(" "),a("p",[n._v("3.3 负载均衡器的设计与实现")]),n._v(" "),a("p",[n._v("Sunny软件公司承接了一个服务器负载均衡(Load Balance)软件的开发工作，该软件运行在一台负载均衡服务器上，可以将并发访问和数据流量分发到服务器集群中的多台设备上进行并发处理，提高系统的整体处理能力，缩短响应时间。由于集群中的服务器需要动态删减，且客户端请求需要统一分发，因此需要确保负载均衡器的唯一性，只能有一个负载均衡器来负责服务器的管理和请求的分发，否则将会带来服务器状态的不一致以及请求分配冲突等问题。如何确保负载均衡器的唯一性是该软件成功的关键。")]),n._v(" "),a("p",[n._v("Sunny公司开发人员通过分析和权衡，决定使用单例模式来设计该负载均衡器，结构图如图3-3所示：")]),n._v(" "),a("p",[a("img",{attrs:{src:"http://my.csdn.net/uploads/201204/02/1333305551_9779.gif",alt:""}})]),n._v(" "),a("p",[n._v("在图3-3中，将负载均衡器LoadBalancer设计为单例类，其中包含一个存储服务器信息的集合serverList，每次在serverList中随机选择一台服务器来响应客户端的请求，实现代码如下所示：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("import java.util.*;  \n  \n//负载均衡器LoadBalancer：单例类，真实环境下该类将非常复杂，包括大量初始化的工作和业务方法，考虑到代码的可读性和易理解性，只列出部分与模式相关的核心代码  \nclass LoadBalancer {  \n    //私有静态成员变量，存储唯一实例  \n    private static LoadBalancer instance = null;  \n    //服务器集合  \n    private List serverList = null;  \n      \n    //私有构造函数  \n    private LoadBalancer() {  \n        serverList = new ArrayList();  \n    }  \n      \n    //公有静态成员方法，返回唯一实例  \n    public static LoadBalancer getLoadBalancer() {  \n        if (instance == null) {  \n            instance = new LoadBalancer();  \n        }  \n        return instance;  \n    }  \n      \n    //增加服务器  \n    public void addServer(String server) {  \n        serverList.add(server);  \n    }  \n      \n    //删除服务器  \n    public void removeServer(String server) {  \n        serverList.remove(server);  \n    }  \n      \n    //使用Random类随机获取服务器  \n    public String getServer() {  \n        Random random = new Random();  \n        int i = random.nextInt(serverList.size());  \n        return (String)serverList.get(i);  \n    }  \n}  \n")])])]),a("p",[n._v("编写如下客户端测试代码：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('\nclass Client {  \n    public static void main(String args[]) {  \n        //创建四个LoadBalancer对象  \n        LoadBalancer balancer1,balancer2,balancer3,balancer4;  \n        balancer1 = LoadBalancer.getLoadBalancer();  \n        balancer2 = LoadBalancer.getLoadBalancer();  \n        balancer3 = LoadBalancer.getLoadBalancer();  \n        balancer4 = LoadBalancer.getLoadBalancer();  \n          \n        //判断服务器负载均衡器是否相同  \n        if (balancer1 == balancer2 && balancer2 == balancer3 && balancer3 == balancer4) {  \n            System.out.println("服务器负载均衡器具有唯一性！");  \n        }  \n          \n        //增加服务器  \n        balancer1.addServer("Server 1");  \n        balancer1.addServer("Server 2");  \n        balancer1.addServer("Server 3");  \n        balancer1.addServer("Server 4");  \n          \n        //模拟客户端请求的分发  \n        for (int i = 0; i < 10; i++) {  \n            String server = balancer1.getServer();  \n            System.out.println("分发请求至服务器： " + server);  \n      }  \n    }  \n}  \n\n')])])]),a("p",[n._v("编译并运行程序，输出结果如下：")]),n._v(" "),a("p",[n._v("服务器负载均衡器具有唯一性！")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("分发请求至服务器：  Server 1\n分发请求至服务器：  Server 3\n分发请求至服务器：  Server 4\n分发请求至服务器：  Server 2\n分发请求至服务器：  Server 3\n分发请求至服务器：  Server 2\n分发请求至服务器：  Server 3\n分发请求至服务器：  Server 4\n分发请求至服务器：  Server 4\n分发请求至服务器：  Server 1\n\n")])])]),a("p",[n._v("虽然创建了四个LoadBalancer对象，但是它们实际上是同一个对象，因此，通过使用单例模式可以确保LoadBalancer对象的唯一性。")])])}),[],!1,null,null,null);e.default=t.exports}}]);