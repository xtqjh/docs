(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{406:function(t,e,v){"use strict";v.r(e);var a=v(42),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"对象间的联动-观察者模式-四"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对象间的联动-观察者模式-四"}},[t._v("#")]),t._v(" 对象间的联动——观察者模式（四）")]),t._v(" "),v("p",[t._v("22.4 JDK对观察者模式的支持")]),t._v(" "),v("p",[t._v("观察者模式在Java语言中的地位非常重要。在JDK的java.util包中，提供了Observable类以及Observer接口，它们构成了JDK对观察者模式的支持。如图22-5所示：")]),t._v(" "),v("p",[v("img",{attrs:{src:"http://my.csdn.net/uploads/201207/06/1341504430_1842.jpg",alt:""}})]),t._v(" "),v("p",[t._v("图22-5 JDK提供的Observable类及Observer接口结构图")]),t._v(" "),v("p",[t._v("(1)  Observer接口")]),t._v(" "),v("p",[t._v("在java.util.Observer接口中只声明一个方法，它充当抽象观察者，其方法声明代码如下所示：")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("void  update(Observable o, Object arg);\n")])])]),v("p",[t._v("当观察目标的状态发生变化时，该方法将会被调用，在Observer的子类中将实现update()方法，即具体观察者可以根据需要具有不同的更新行为。当调用观察目标类Observable的notifyObservers()方法时，将执行观察者类中的update()方法。")]),t._v(" "),v("p",[t._v("(2)  Observable类")]),t._v(" "),v("p",[t._v("java.util.Observable类充当观察目标类，在Observable中定义了一个向量Vector来存储观察者对象，它所包含的方法及说明见表22-1：\n表22-1 Observable类所包含方法及说明")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("方法名")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("方法描述")]),t._v(" "),v("th",{staticStyle:{"text-align":"right"}},[t._v("Cool")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("Observable()")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("构造方法，实例化Vector向量。")]),t._v(" "),v("td",{staticStyle:{"text-align":"right"}},[t._v("$1600")])]),t._v(" "),v("tr",[v("td",[t._v("addObserver(Observer  o)")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("用于注册新的观察者对象到向量中。")]),t._v(" "),v("td",{staticStyle:{"text-align":"right"}},[t._v("$12")])]),t._v(" "),v("tr",[v("td",[t._v("deleteObserver  (Observer o)")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("用于删除向量中的某一个观察者对象。")]),t._v(" "),v("td",{staticStyle:{"text-align":"right"}},[t._v("$1")])]),t._v(" "),v("tr",[v("td",[t._v("notifyObservers()和notifyObservers(Object arg)")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("通知方法，用于在方法内部循环调用向量中每一个观察者的update()方法。")]),t._v(" "),v("td",{staticStyle:{"text-align":"right"}})]),t._v(" "),v("tr",[v("td",[t._v("deleteObservers()")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("用于清空向量，即删除向量中所有观察者对象。")]),t._v(" "),v("td",{staticStyle:{"text-align":"right"}})]),t._v(" "),v("tr",[v("td",[t._v("setChanged()")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("该方法被调用后会设置一个boolean类型的内部标记变量changed的值为true，表示观察目标对象的状态发生了变化。")]),t._v(" "),v("td",{staticStyle:{"text-align":"right"}})]),t._v(" "),v("tr",[v("td",[t._v("clearChanged()")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("用于将changed变量的值设为false，表示对象状态不再发生改变或者已经通知了所有的观察者对象，调用了它们的update()方法。")]),t._v(" "),v("td",{staticStyle:{"text-align":"right"}})]),t._v(" "),v("tr",[v("td",[t._v("hasChanged()")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("用于测试对象状态是否改变。")]),t._v(" "),v("td",{staticStyle:{"text-align":"right"}})]),t._v(" "),v("tr",[v("td",[t._v("countObservers()")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("用于返回向量中观察者的数量。")]),t._v(" "),v("td",{staticStyle:{"text-align":"right"}})])])]),t._v(" "),v("p",[t._v("我们可以直接使用Observer接口和Observable类来作为观察者模式的抽象层，再自定义具体观察者类和具体观察目标类，通过使用JDK中的Observer接口和Observable类，可以更加方便地在Java语言中应用观察者模式。")])])}),[],!1,null,null,null);e.default=r.exports}}]);