(window.webpackJsonp=window.webpackJsonp||[]).push([[143],{489:function(e,n,a){"use strict";a.r(n);var m=a(42),u=Object(m.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"请求发送者与接收者解耦-命令模式-三"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请求发送者与接收者解耦-命令模式-三"}},[e._v("#")]),e._v(" 请求发送者与接收者解耦——命令模式（三）")]),e._v(" "),a("p",[e._v("4 命令队列的实现")]),e._v(" "),a("p",[e._v("有时候我们需要将多个请求排队，当一个请求发送者发送一个请求时，将不止一个请求接收者产生响应，这些请求接收者将逐个执行业务方法，完成对请求的处理。此时，我们可以通过命令队列来实现。")]),e._v(" "),a("p",[e._v("命令队列的实现方法有多种形式，其中最常用、灵活性最好的一种方式是增加一个CommandQueue类，由该类来负责存储多个命令对象，而不同的命令对象可以对应不同的请求接收者，CommandQueue类的典型代码如下所示：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("import java.util.*;  \n  \nclass CommandQueue {  \n    //定义一个ArrayList来存储命令队列  \n    private ArrayList<Command> commands = new ArrayList<Command>();  \n      \n    public void addCommand(Command command) {  \n        commands.add(command);  \n    }  \n      \n    public void removeCommand(Command command) {  \n        commands.remove(command);  \n    }  \n      \n    //循环调用每一个命令对象的execute()方法  \n    public void execute() {  \n        for (Object command : commands) {  \n            ((Command)command).execute();  \n        }  \n    }  \n}  \n")])])]),a("p",[e._v("在增加了命令队列类CommandQueue以后，请求发送者类Invoker将针对CommandQueue编程，代码修改如下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class Invoker {  \n    private CommandQueue commandQueue; //维持一个CommandQueue对象的引用  \n      \n    //构造注入  \n    public Invoker(CommandQueue commandQueue) {  \n        this. commandQueue = commandQueue;  \n    }  \n      \n    //设值注入  \n    public void setCommandQueue(CommandQueue commandQueue) {  \n        this.commandQueue = commandQueue;  \n    }  \n      \n    //调用CommandQueue类的execute()方法  \n    public void call() {  \n        commandQueue.execute();  \n    }  \n}  \n")])])]),a("p",[e._v("命令队列与我们常说的“批处理”有点类似。批处理，顾名思义，可以对一组对象（命令）进行批量处理，当一个发送者发送请求后，将有一系列接收者对请求作出响应，命令队列可以用于设计批处理应用程序，如果请求接收者的接收次序没有严格的先后次序，我们还可以使用多线程技术来并发调用命令对象的execute()方法，从而提高程序的执行效率。")])])}),[],!1,null,null,null);n.default=u.exports}}]);