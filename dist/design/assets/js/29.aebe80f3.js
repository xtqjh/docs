(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{375:function(n,e,a){"use strict";a.r(e);var t=a(42),i=Object(t.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"处理多维度变化-桥接模式-三"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#处理多维度变化-桥接模式-三"}},[n._v("#")]),n._v(" 处理多维度变化——桥接模式（三）")]),n._v(" "),a("p",[n._v("10.3  完整解决方案")]),n._v(" "),a("p",[n._v("为了减少所需生成的子类数目，实现将操作系统和图像文件格式两个维度分离，使它们可以独立改变，Sunny公司开发人员使用桥接模式来重构跨平台图像浏览系统的设计，其基本结构如图10-5所示：")]),n._v(" "),a("p",[a("img",{attrs:{src:"http://my.csdn.net/uploads/201204/16/1334506504_5936.gif",alt:""}})]),n._v(" "),a("p",[n._v("在图10-5中，Image充当抽象类，其子类JPGImage、PNGImage、BMPImage和GIFImage充当扩充抽象类；ImageImp充当实现类接口，其子类WindowsImp、LinuxImp和UnixImp充当具体实现类。完整代码如下所示：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('//像素矩阵类：辅助类，各种格式的文件最终都被转化为像素矩阵，不同的操作系统提供不同的方式显示像素矩阵  \nclass Matrix {  \n    //此处代码省略  \n}  \n  \n//抽象图像类：抽象类  \nabstract class Image {  \n    protected ImageImp imp;  \n  \n    public void setImageImp(ImageImp imp) {  \n        this.imp = imp;  \n    }   \n  \n    public abstract void parseFile(String fileName);  \n}  \n  \n//抽象操作系统实现类：实现类接口  \ninterface ImageImp {  \n    public void doPaint(Matrix m);  //显示像素矩阵m  \n}   \n  \n//Windows操作系统实现类：具体实现类  \nclass WindowsImp implements ImageImp {  \n    public void doPaint(Matrix m) {  \n        //调用Windows系统的绘制函数绘制像素矩阵  \n        System.out.print("在Windows操作系统中显示图像：");  \n    }  \n}  \n  \n//Linux操作系统实现类：具体实现类  \nclass LinuxImp implements ImageImp {  \n    public void doPaint(Matrix m) {  \n        //调用Linux系统的绘制函数绘制像素矩阵  \n        System.out.print("在Linux操作系统中显示图像：");  \n    }  \n}  \n  \n//Unix操作系统实现类：具体实现类  \nclass UnixImp implements ImageImp {  \n    public void doPaint(Matrix m) {  \n        //调用Unix系统的绘制函数绘制像素矩阵  \n        System.out.print("在Unix操作系统中显示图像：");  \n    }  \n}  \n  \n//JPG格式图像：扩充抽象类  \nclass JPGImage extends Image {  \n    public void parseFile(String fileName) {  \n        //模拟解析JPG文件并获得一个像素矩阵对象m;  \n        Matrix m = new Matrix();   \n        imp.doPaint(m);  \n        System.out.println(fileName + "，格式为JPG。");  \n    }  \n}  \n  \n//PNG格式图像：扩充抽象类  \nclass PNGImage extends Image {  \n    public void parseFile(String fileName) {  \n        //模拟解析PNG文件并获得一个像素矩阵对象m;  \n        Matrix m = new Matrix();   \n        imp.doPaint(m);  \n        System.out.println(fileName + "，格式为PNG。");  \n    }  \n}  \n  \n//BMP格式图像：扩充抽象类  \nclass BMPImage extends Image {  \n    public void parseFile(String fileName) {  \n        //模拟解析BMP文件并获得一个像素矩阵对象m;  \n        Matrix m = new Matrix();   \n        imp.doPaint(m);  \n        System.out.println(fileName + "，格式为BMP。");  \n    }  \n}  \n  \n//GIF格式图像：扩充抽象类  \nclass GIFImage extends Image {  \n    public void parseFile(String fileName) {  \n        //模拟解析GIF文件并获得一个像素矩阵对象m;  \n        Matrix m = new Matrix();   \n        imp.doPaint(m);  \n        System.out.println(fileName + "，格式为GIF。");  \n    }  \n}  \n')])])]),a("p",[n._v("为了让系统具有更好的灵活性和可扩展性，我们引入了配置文件，将具体扩充抽象类和具体实现类类名都存储在配置文件中，再通过反射生成对象，将生成的具体实现类对象注入到扩充抽象类对象中，其中，配置文件config.xml的代码如下所示：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('<?xml version="1.0"?>  \n<config>  \n    \x3c!--RefinedAbstraction--\x3e  \n    <className>JPGImage</className>   \n    \x3c!--ConcreteImplementor--\x3e  \n    <className>WindowsImp</className>  \n</config> \n')])])]),a("p",[n._v("用于读取配置文件config.xml并反射生成对象的XMLUtil类的代码如下所示：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('import javax.xml.parsers.*;  \nimport org.w3c.dom.*;  \nimport org.xml.sax.SAXException;  \nimport java.io.*;  \npublic class XMLUtil {  \n//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象  \n    public static Object getBean(String args) {  \n        try {  \n            //创建文档对象  \n            DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();  \n            DocumentBuilder builder = dFactory.newDocumentBuilder();  \n            Document doc;                             \n            doc = builder.parse(new File("config.xml"));   \n            NodeList nl=null;  \n            Node classNode=null;  \n            String cName=null;  \n            nl = doc.getElementsByTagName("className");  \n              \n            if(args.equals("image")) {  \n                //获取第一个包含类名的节点，即扩充抽象类  \n                classNode=nl.item(0).getFirstChild();  \n                  \n            }  \n            else if(args.equals("os")) {  \n               //获取第二个包含类名的节点，即具体实现类  \n                classNode=nl.item(1).getFirstChild();  \n            }  \n              \n             cName=classNode.getNodeValue();  \n             //通过类名生成实例对象并将其返回  \n             Class c=Class.forName(cName);  \n             Object obj=c.newInstance();  \n             return obj;          \n           }     \n           catch(Exception e) {  \n              e.printStackTrace();  \n              return null;  \n          }  \n     }  \n}  \n')])])]),a("p",[n._v("编写如下客户端测试代码：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('class Client {  \n    public static void main(String args[]) {  \n        Image image;  \n        ImageImp imp;  \n        image = (Image)XMLUtil.getBean("image");  \n        imp = (ImageImp)XMLUtil.getBean("os");  \n        image.setImageImp(imp);  \n        image.parseFile("小龙女");  \n    }  \n}  \n')])])]),a("p",[n._v("编译并运行程序，输出结果如下：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("在Windows操作系统中显示图像：小龙女，格式为JPG。\n")])])]),a("p",[n._v("如果需要更换图像文件格式或者更换操作系统，只需修改配置文件即可，在实际使用时，可以通过分析图像文件格式后缀名来确定具体的文件格式，在程序运行时获取操作系统信息来确定操作系统类型，无须使用配置文件。当增加新的图像文件格式或者操作系统时，原有系统无须做任何修改，只需增加一个对应的扩充抽象类或具体实现类即可，系统具有较好的可扩展性，完全符合“开闭原则”。")])])}),[],!1,null,null,null);e.default=i.exports}}]);