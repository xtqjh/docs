(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{355:function(n,t,r){"use strict";r.r(t);var a=r(42),e=Object(a.a)({},(function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[r("h1",{attrs:{id:"不兼容结构的协调-适配器模式-二"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#不兼容结构的协调-适配器模式-二"}},[n._v("#")]),n._v(" 不兼容结构的协调——适配器模式（二）")]),n._v(" "),r("p",[n._v("9.3 完整解决方案")]),n._v(" "),r("p",[n._v("Sunny软件公司开发人员决定使用适配器模式来重用算法库中的算法，其基本结构如图9-4所示：")]),n._v(" "),r("p",[r("img",{attrs:{src:"http://img.my.csdn.net/uploads/201303/01/1362069067_3033.jpg",alt:""}})]),n._v(" "),r("p",[n._v("图9-4  算法库重用结构图")]),n._v(" "),r("p",[n._v("在图9-4中，ScoreOperation接口充当抽象目标，QuickSort和BinarySearch类充当适配者，OperationAdapter充当适配器。完整代码如下所示：")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("//抽象成绩操作类：目标接口  \ninterface ScoreOperation {  \n    public int[] sort(int array[]); //成绩排序  \n    public int search(int array[],int key); //成绩查找  \n}  \n  \n//快速排序类：适配者  \nclass QuickSort {  \n    public int[] quickSort(int array[]) {  \n        sort(array,0,array.length-1);  \n        return array;  \n    }  \n  \n    public void sort(int array[],int p, int r) {  \n        int q=0;  \n        if(p<r) {  \n            q=partition(array,p,r);  \n            sort(array,p,q-1);  \n            sort(array,q+1,r);  \n        }  \n    }  \n  \n    public int partition(int[] a, int p, int r) {  \n        int x=a[r];  \n        int j=p-1;  \n        for (int i=p;i<=r-1;i++) {  \n            if (a[i]<=x) {  \n                j++;  \n                swap(a,j,i);  \n            }  \n        }  \n        swap(a,j+1,r);  \n        return j+1;   \n    }  \n  \n    public void swap(int[] a, int i, int j) {     \n        int t = a[i];     \n        a[i] = a[j];     \n        a[j] = t;     \n    }  \n}  \n  \n//二分查找类：适配者  \nclass BinarySearch {  \n    public int binarySearch(int array[],int key) {  \n        int low = 0;  \n        int high = array.length -1;  \n        while(low <= high) {  \n            int mid = (low + high) / 2;  \n            int midVal = array[mid];  \n            if(midVal < key) {    \nlow = mid +1;    \n}  \n            else if (midVal > key) {    \nhigh = mid -1;    \n}  \n            else {    \nreturn 1; //找到元素返回1    \n}  \n        }  \n        return -1;  //未找到元素返回-1  \n    }  \n}  \n  \n//操作适配器：适配器  \nclass OperationAdapter implements ScoreOperation {  \n    private QuickSort sortObj; //定义适配者QuickSort对象  \n    private BinarySearch searchObj; //定义适配者BinarySearch对象  \n  \n    public OperationAdapter() {  \n        sortObj = new QuickSort();  \n        searchObj = new BinarySearch();  \n    }  \n  \n    public int[] sort(int array[]) {    \nreturn sortObj.quickSort(array); //调用适配者类QuickSort的排序方法  \n}  \n  \n    public int search(int array[],int key) {    \nreturn searchObj.binarySearch(array,key); //调用适配者类BinarySearch的查找方法  \n}  \n}  \n")])])]),r("p",[n._v("为了让系统具备良好的灵活性和可扩展性，我们引入了工具类XMLUtil和配置文件，其中，XMLUtil")]),n._v(" "),r("p",[n._v("类的代码如下所示：")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v('import javax.xml.parsers.*;  \nimport org.w3c.dom.*;  \nimport org.xml.sax.SAXException;  \nimport java.io.*;  \nclass XMLUtil {  \n//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象  \n    public static Object getBean() {  \n        try {  \n            //创建文档对象  \n            DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();  \n            DocumentBuilder builder = dFactory.newDocumentBuilder();  \n            Document doc;                             \n            doc = builder.parse(new File("config.xml"));   \n          \n            //获取包含类名的文本节点  \n            NodeList nl = doc.getElementsByTagName("className");  \n            Node classNode=nl.item(0).getFirstChild();  \n            String cName=classNode.getNodeValue();  \n              \n            //通过类名生成实例对象并将其返回  \n            Class c=Class.forName(cName);  \n            Object obj=c.newInstance();  \n            return obj;  \n        }     \n        catch(Exception e) {  \n            e.printStackTrace();  \n            return null;  \n        }  \n    }  \n}  \n')])])]),r("p",[n._v("配置文件config.xml中存储了适配器类的类名，代码如下所示：")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v('<?xml version="1.0"?>  \n<config>  \n    <className>OperationAdapter</className>  \n</config>  \n')])])]),r("p",[n._v("编写如下客户端测试代码：")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v('class Client {  \n    public static void main(String args[]) {  \n        ScoreOperation operation;  //针对抽象目标接口编程  \n        operation = (ScoreOperation)XMLUtil.getBean(); //读取配置文件，反射生成对象  \n        int scores[] = {84,76,50,69,90,91,88,96}; //定义成绩数组  \n        int result[];  \n        int score;  \n          \n        System.out.println("成绩排序结果：");  \n        result = operation.sort(scores);  \n  \n        //遍历输出成绩  \n        for(int i : scores) {  \n            System.out.print(i + ",");  \n        }  \n        System.out.println();  \n          \n        System.out.println("查找成绩90：");  \n        score = operation.search(result,90);  \n        if (score != -1) {  \n            System.out.println("找到成绩90。");  \n        }  \n        else {  \n            System.out.println("没有找到成绩90。");  \n        }  \n          \n        System.out.println("查找成绩92：");  \n        score = operation.search(result,92);  \n        if (score != -1) {  \n            System.out.println("找到成绩92。");  \n        }  \n        else {  \n            System.out.println("没有找到成绩92。");  \n        }  \n    }  \n}  \n')])])]),r("p",[n._v("编译并运行程序，输出结果如下：")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("成绩排序结果：\n50,69,76,84,88,90,91,96,\n查找成绩90：\n找到成绩90。\n查找成绩92：\n没有找到成绩92。\n")])])]),r("p",[n._v("在本实例中使用了对象适配器模式，同时引入了配置文件，将适配器类的类名存储在配置文件中。如果需要使用其他排序算法类和查找算法类，可以增加一个新的适配器类，使用新的适配器来适配新的算法，原有代码无须修改。通过引入配置文件和反射机制，可以在不修改客户端代码的情况下使用新的适配器，无须修改源代码，符合“开闭原则”。")])])}),[],!1,null,null,null);t.default=e.exports}}]);